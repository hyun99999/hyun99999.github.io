---
title:  "Algorithm) Floyd-Warshall(플로이드-워셜) 알고리즘"
categories:
- iOS

date:   2022-08-31  17:05:00 +0900
author_profile: false
---
**플로이드 워셜(Floyd-Warshall)은 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우 에 사용할 수 있는 알고리즘이다.**

- 매번 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾을 필요가 없다는 점이 **다익스트라**와 다른 점이다.

노드의 개수가 n 개일때 **n 번의 단계**를 수행하며 단계마다 O(N²) 의 연산을 통해 현재 노드를 거쳐가는 모든 경로를 고려한다. 그래서 총 시간 복잡도는 O(N³)이다.

즉, 모든 지점을 시작으로 삼고 모든 지점에 대해서 끝으로 삼아서 최단 거리를 구하는데 모든 노드를 경유지로 삼는 과정인 **n 번의 단계**를 수행 한다. **min(시작 → 끝, 시작 → 경유 + 경유 → 끝) 를 구하는 것이다.**

- **다익스트라 알고리즘**은 출발 노드가 1개이므로 다른 모든 노드까지의 최단 거리를 저장하기 위해 1차원 배열을 사용하였다.
- 반면에 **플로이드-워셜 알고리즘**은 모든 노드에 대해서 다른 모든 노드로의 최단 거리를 저장해야 하기 때문에 2차원 배열을 사용해야 한다. 이때문에 n 번의 단계마다 O(N²) 의 시간이 소요된다는 것이다.

- **다이스트라 알고리즘**은 그리디 알고리즘이다.
- **플로이드-워셜 알고리즘**은 n 번 만큼의 단계를 반복하며 점화식에 맞게 2차원 배열을 배열을 갱신하기 때문에 다이나믹 프로그래밍이다.

전체적으로 3중 반복문을 잉요하여 최단 거리 배열을 갱신하면 된다. 핵심 개념에 대해서 Swift 로 구현된 예시 코드를 살펴보자.

```swift
var answer = 0
// 최단 거리를 가지는 2차원 배열
var node: [[Int]] = []

// 지점 사이의 요금은 1이상 100,000이하.
// 지점의 총 갯수 n 은 최대 200개.
// ✅ 요금의 최대값은 가장 비싼 요금의 모든 지점을 거치는 경우이므로 200 * 100000 로 표현 가능.
// 이때 Int.max 를 사용하면 메모리 초과가 발생하기도 한다.
node = Array(repeating: Array(repeating: 200 * 100000, count: n + 1), count: n + 1)

// Floyd-Warshal 알고리즘
for i in 1...n { // 경유지 1...n 
    for j in 1...n {
        for k in 1...n {
            if node[j][k] > node[j][i] + node[i][k] {
                node[j][k] = node[j][i] + node[i][k]
            }
        }
    }
}

// 시작점에서 AB 각각으로 이동하는 경우.
answer = node[s][a] + node[s][b]
    
// ✅ n번의 단계에서 최단 경로 구하기
for i in 1...n {
    answer = min(answer, node[s][i] + node[i][a] + node[i][b])
}

// 출처: 2021 KAKAO BLIND RECURITMENT - 합승 택시 요금
```
